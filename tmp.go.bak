package main

import (
	"fmt"
)

//func main() {
//	target := int64(5001)
//	inputs := []int64{4000, 2000}
//	outputs, err := UnderlyingForSigning(target, inputs)
//	if err != nil {
//		log.Fatal(err)
//	}
//	fmt.Printf("%v\n", inputs)
//	fmt.Printf("%v\n", outputs)
//
//}

//func UnderlyingForSigningx(target int64, inputs []int64) (outputs []int64, err error) {
//
//	remainder := int64(target % existentialDeposit)
//	fee := int64(1000)
//	sendingAmount := int64(0)
//	// split amount
//	// EDs in input[0]
//	edsInTarget := target / existentialDeposit
//	firstAmount := (edsInTarget - edsToRetain) + remainder
//	secondAmount := target - firstAmount
//	outputsFirst, _ := buildInputsOutputs(firstAmount, inputs)
//	outputsSecond, _ := buildInputsOutputs(secondAmount, inputs)
//
//}

func XXXbuildInputsOutputs(target int64, inputs []int64) (outputs []int64, err error) {
	for i, inputAmount := range inputs {
		canPayAllRetainingED := inputAmount-fee-existentialDeposit >= target
		canPayAllRetainingDust := inputAmount-fee > target && !canPayAllRetainingED
		canPayAllRetainingZero := inputAmount-fee == target
		canPaySomeRetainingED := inputAmount-fee-existentialDeposit < target
		canPaySomeRetainingZero := inputAmount-fee < target

		fmt.Printf("input %d\n", i)
		fmt.Printf("canPayAllRetainingED: %v\n", canPayAllRetainingED)
		fmt.Printf("canPayAllRetainingDust: %v\n", canPayAllRetainingDust)
		fmt.Printf("canPayAllRetainingZero: %v\n", canPayAllRetainingZero)
		fmt.Printf("canPaySomeRetainingED: %v\n", canPaySomeRetainingED)
		fmt.Printf("canPaySomeRetainingZero: %v\n", canPaySomeRetainingZero)
		fmt.Println("--------------------------------")

		if canPayAllRetainingED {
			sendingAmount = target
			inputs[i] = inputAmount - target - fee
			target = 0
			break
		}

		if canPaySomeRetainingED {
		}
	}
	fmt.Printf("sendingAmount (total): %d\n", sendingAmount)
	fmt.Printf("%v\n", inputs)

	return

}
